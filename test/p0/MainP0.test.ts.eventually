import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers'
import { expect } from 'chai'
import { BigNumber, FixedNumber, ContractFactory, Wallet } from 'ethers'
import { ethers, waffle } from 'hardhat'

import {
  BN_SCALE_FACTOR,
  FURNACE_DEST,
  Mood,
  STRSR_DEST,
  ZERO_ADDRESS,
} from '../../common/constants'
import { bn, fp } from '../../common/numbers'
import { AAVEAssetP0 } from '../../typechain/AAVEAssetP0'
import { AaveLendingPoolMockP0 } from '../../typechain/AaveLendingPoolMockP0'
import { AaveOracleMockP0 } from '../../typechain/AaveOracleMockP0'
import { AToken } from '../../typechain/AToken'
import { ATokenFiatCollateralP0 } from '../../typechain/ATokenFiatCollateralP0'
import { BackingTraderP0 } from '../../typechain/BackingTraderP0'
import { CollateralP0 } from '../../typechain/CollateralP0'
import { COMPAssetP0 } from '../../typechain/COMPAssetP0'
import { CompoundOracleMockP0 } from '../../typechain/CompoundOracleMockP0'
import { ComptrollerMockP0 } from '../../typechain/ComptrollerMockP0'
import { CTokenFiatCollateralP0 } from '../../typechain/CTokenFiatCollateralP0'
import { CTokenMock } from '../../typechain/CTokenMock'
import { DeployerP0 } from '../../typechain/DeployerP0'
import { ERC20Mock } from '../../typechain/ERC20Mock'
import { FurnaceP0 } from '../../typechain/FurnaceP0'
import { MainP0 } from '../../typechain/MainP0'
import { MarketMock } from '../../typechain/MarketMock'
import { RevenueTraderP0 } from '../../typechain/RevenueTraderP0'
import { RSRAssetP0 } from '../../typechain/RSRAssetP0'
import { RTokenAssetP0 } from '../../typechain/RTokenAssetP0'
import { RTokenP0 } from '../../typechain/RTokenP0'
import { StaticATokenMock } from '../../typechain/StaticATokenMock'
import { StRSRP0 } from '../../typechain/StRSRP0'
import { TraderP0 } from '../../typechain/TraderP0'
import { USDCMock } from '../../typechain/USDCMock'
import { VaultP0 } from '../../typechain/VaultP0'
import { advanceTime, advanceToTimestamp, getLatestBlockTimestamp } from '../utils/time'
import { Collateral, defaultFixture, IConfig, IRevenueShare } from './utils/fixtures'

const createFixtureLoader = waffle.createFixtureLoader

enum AuctionStatus {
  NOT_YET_OPEN,
  OPEN,
  DONE,
}

interface IAuctionInfo {
  sell: string
  buy: string
  sellAmount: BigNumber
  minBuyAmount: BigNumber
  startTime: number
  endTime: number
  clearingSellAmount: BigNumber
  clearingBuyAmount: BigNumber
  externalAuctionId: BigNumber
  status: AuctionStatus
}

describe('MainP0 contract', () => {
  let owner: SignerWithAddress
  let addr1: SignerWithAddress
  let addr2: SignerWithAddress
  let other: SignerWithAddress

  // Deployer contract
  let deployer: DeployerP0

  // Vault and Assets
  let collateral: Collateral[]
  let VaultFactory: ContractFactory
  let vault: VaultP0

  // Non-backing assets
  let rsr: ERC20Mock
  let rsrAsset: RSRAssetP0
  let compAsset: COMPAssetP0
  let compoundMock: ComptrollerMockP0
  let compoundOracle: CompoundOracleMockP0
  let aaveToken: ERC20Mock
  let aaveAsset: AAVEAssetP0
  let aaveMock: AaveLendingPoolMockP0
  let aaveOracle: AaveOracleMockP0

  // Trading
  let market: MarketMock
  let rsrTrader: RevenueTraderP0
  let rTokenTrader: RevenueTraderP0
  let backingTrader: BackingTraderP0

  // Tokens and Assets
  let initialBal: BigNumber
  let token0: ERC20Mock
  let token1: USDCMock
  let token2: StaticATokenMock
  let token3: CTokenMock
  let collateral0: CollateralP0
  let collateral1: CollateralP0
  let collateral2: ATokenFiatCollateralP0
  let collateral3: CTokenFiatCollateralP0

  // Config values
  let config: IConfig
  let dist: IRevenueShare

  // Contracts to retrieve after deploy
  let rToken: RTokenP0
  let stRSR: StRSRP0
  let furnace: FurnaceP0
  let main: MainP0

  let loadFixture: ReturnType<typeof createFixtureLoader>
  let wallet: Wallet

  const expectAuctionInfo = async (
    trader: TraderP0,
    index: number,
    auctionInfo: Partial<IAuctionInfo>
  ) => {
    const {
      sell,
      buy,
      sellAmount,
      minBuyAmount,
      startTime,
      endTime,
      clearingSellAmount,
      clearingBuyAmount,
      status,
    } = await trader.auctions(index)
    expect(sell).to.equal(auctionInfo.sell)
    expect(buy).to.equal(auctionInfo.buy)
    expect(sellAmount).to.equal(auctionInfo.sellAmount)
    expect(minBuyAmount).to.equal(auctionInfo.minBuyAmount)
    expect(startTime).to.equal(auctionInfo.startTime)
    expect(endTime).to.equal(auctionInfo.endTime)
    expect(clearingSellAmount).to.equal(auctionInfo.clearingSellAmount)
    expect(clearingBuyAmount).to.equal(auctionInfo.clearingBuyAmount)
    expect(status).to.equal(auctionInfo.status)
  }

  const expectAuctionStatus = async (
    trader: TraderP0,
    index: number,
    expectedStatus: AuctionStatus
  ) => {
    const { status } = await trader.auctions(index)
    expect(status).to.equal(expectedStatus)
  }

  before('create fixture loader', async () => {
    ;[wallet] = await (ethers as any).getSigners()
    loadFixture = createFixtureLoader([wallet])
  })

  beforeEach(async () => {
    ;[owner, addr1, addr2, other] = await ethers.getSigners()
    let erc20s: ERC20Mock[]
    let basket: Collateral[]
      // Deploy fixture
    ;({
      rsr,
      rsrAsset,
      aaveToken,
      compAsset,
      aaveAsset,
      compoundOracle,
      aaveOracle,
      compoundMock,
      aaveMock,
      erc20s,
      collateral,
      basket,
      vault,
      config,
      deployer,
      dist,
      main,
      rToken,
      furnace,
      stRSR,
      market,
    } = await loadFixture(defaultFixture))
    token0 = erc20s[collateral.indexOf(basket[0])]
    token1 = erc20s[collateral.indexOf(basket[1])]
    token2 = <StaticATokenMock>erc20s[collateral.indexOf(basket[2])]
    token3 = <CTokenMock>erc20s[collateral.indexOf(basket[3])]

    // Set Aave revenue token
    await token2.setAaveToken(aaveToken.address)

    collateral0 = basket[0]
    collateral1 = basket[1]
    collateral2 = <ATokenFiatCollateralP0>basket[2]
    collateral3 = <CTokenFiatCollateralP0>basket[3]

    rsrTrader = <RevenueTraderP0>(
      await ethers.getContractAt('RevenueTraderP0', await main.rsrTrader())
    )
    rTokenTrader = <RevenueTraderP0>(
      await ethers.getContractAt('RevenueTraderP0', await main.rTokenTrader())
    )
    backingTrader = <BackingTraderP0>(
      await ethers.getContractAt('BackingTraderP0', await main.backingTrader())
    )

    // Mint initial balances
    initialBal = bn('1000000e18')
    await token0.connect(owner).mint(addr1.address, initialBal)
    await token1.connect(owner).mint(addr1.address, initialBal)
    await token2.connect(owner).mint(addr1.address, initialBal)
    await token3.connect(owner).mint(addr1.address, initialBal)

    await token0.connect(owner).mint(addr2.address, initialBal)
    await token1.connect(owner).mint(addr2.address, initialBal)
    await token2.connect(owner).mint(addr2.address, initialBal)
    await token3.connect(owner).mint(addr2.address, initialBal)

    // Set Vault Factory (for creating additional vaults in tests)
    VaultFactory = await ethers.getContractFactory('VaultP0')

    // Setup Main
    await vault.connect(owner).setMain(main.address)
  })

  describe('Notice Default', function () {
    let issueAmount: BigNumber

    beforeEach(async function () {
      // Issue some RTokens to user
      issueAmount = bn('100e18')
      // Provide approvals
      await token0.connect(addr1).approve(main.address, initialBal)
      await token1.connect(addr1).approve(main.address, initialBal)
      await token2.connect(addr1).approve(main.address, initialBal)
      await token3.connect(addr1).approve(main.address, initialBal)

      // Issue rTokens
      await main.connect(addr1).issue(issueAmount)

      // Process the issuance
      await main.poke()
    })

    it('Should not detect default and not impact state in normal situation', async () => {
      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.fullyCapitalized()).to.equal(true)

      // Notice default
      await expect(main.poke()).to.not.emit

      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.fullyCapitalized()).to.equal(true)
    })

    it('Should detect soft default and change state', async () => {
      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.fullyCapitalized()).to.equal(true)

      // Default one of the tokens - reduce fiatcoin price in terms of Eth
      await aaveOracle.setPrice(token0.address, bn('1.5e14'))

      // Notice default
      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.CALM, Mood.DOUBT)

      expect(await main.mood()).to.equal(Mood.DOUBT)
      expect(await main.fullyCapitalized()).to.equal(true)

      // If soft default is reversed goes back to calm state
      await aaveOracle.setPrice(token0.address, bn('2.5e14'))

      // Notice default
      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.DOUBT, Mood.CALM)

      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.fullyCapitalized()).to.equal(true)
    })

    it('Should switch vaults and start Trading if in "doubt" more than defaultDelay', async () => {
      // Set backup vault
      const backupVault: VaultP0 = <VaultP0>(
        await VaultFactory.deploy(
          [collateral[1].address, collateral[2].address],
          [bn('1e6'), bn('1e18')],
          []
        )
      )
      await vault.setBackups([backupVault.address])

      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.vault()).to.equal(vault.address)
      expect(await main.fullyCapitalized()).to.equal(true)

      // Default one of the tokens - reduce fiatcoin price in terms of Eth
      await aaveOracle.setPrice(token0.address, bn('1.5e14'))

      // Notice default
      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.CALM, Mood.DOUBT)

      expect(await main.mood()).to.equal(Mood.DOUBT)
      expect(await main.vault()).to.equal(vault.address)
      expect(await main.fullyCapitalized()).to.equal(true)

      // Advancing time still before defaultDelay - No change should occur
      await advanceTime(3600)

      // Notice default
      await expect(main.poke()).to.not.emit

      expect(await main.mood()).to.equal(Mood.DOUBT)
      expect(await main.vault()).to.equal(vault.address)
      expect(await main.fullyCapitalized()).to.equal(true)

      // Advance time post defaultDelay
      await advanceTime(config.defaultDelay.toString())

      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.DOUBT, Mood.TRADING)

      // Check state
      expect(await main.mood()).to.equal(Mood.TRADING)
      expect(await main.vault()).to.equal(backupVault.address)
      expect(await main.fullyCapitalized()).to.equal(false)

      // If token enters a soft default and then its restored, it should still keep Trading stat
      await aaveOracle.setPrice(token0.address, bn('2.5e14'))
      await aaveOracle.setPrice(token1.address, bn('0.5e14'))

      // Notice default
      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.TRADING, Mood.DOUBT)

      // Restore price
      await aaveOracle.setPrice(token1.address, bn('2.5e14'))

      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.DOUBT, Mood.TRADING)

      expect(await main.mood()).to.equal(Mood.TRADING)
      expect(await main.vault()).to.equal(backupVault.address)
      expect(await main.fullyCapitalized()).to.equal(false)
    })

    it('Should detect hard default and switch state and vault', async () => {
      // Define AToken
      const ATokenMockFactory = await ethers.getContractFactory('StaticATokenMock')
      const aToken0 = <StaticATokenMock>(
        await ATokenMockFactory.deploy('AToken 0', 'ATKN0', token0.address)
      )
      const aToken1 = <StaticATokenMock>(
        await ATokenMockFactory.deploy('AToken 1', 'ATKN1', token1.address)
      )
      const ATokenAssetFactory = await ethers.getContractFactory('ATokenFiatCollateralP0')
      const assetAToken0 = <ATokenFiatCollateralP0>await ATokenAssetFactory.deploy(aToken0.address)
      const assetAToken1 = <ATokenFiatCollateralP0>await ATokenAssetFactory.deploy(aToken1.address)

      // Check state
      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.vault()).to.equal(vault.address)
      expect(await main.fullyCapitalized()).to.equal(true)

      // Setup new Vault with AToken and capitalize Vault
      const backupVault: VaultP0 = <VaultP0>(
        await VaultFactory.deploy([assetAToken1.address], [bn('1e18')], [])
      )
      const newVault: VaultP0 = <VaultP0>(
        await VaultFactory.deploy([assetAToken0.address], [bn('1e18')], [backupVault.address])
      )

      // Approve new collateral
      await main.connect(owner).approveCollateral(assetAToken0.address)
      await main.connect(owner).approveCollateral(assetAToken1.address)

      // Switch vault
      await main.connect(owner).switchVault(newVault.address)

      // Check state
      expect(await main.mood()).to.equal(Mood.CALM)
      expect(await main.vault()).to.equal(newVault.address)
      expect(await main.fullyCapitalized()).to.equal(false)

      // Call will not trigger hard default nor soft default in normal situation
      await expect(main.poke()).to.emit(main, 'MoodChanged').withArgs(Mood.CALM, Mood.TRADING)

      // Check state
      expect(await main.mood()).to.equal(Mood.TRADING)
      expect(await main.vault()).to.equal(newVault.address)
      expect(await main.fullyCapitalized()).to.equal(false)

      // Set default rate
      await aToken0.setExchangeRate(fp('0.98'))

      // Call to detect vault switch and state change
      await main.poke()

      // check state - backup vault was selected
      expect(await main.mood()).to.equal(Mood.TRADING)
      expect(await main.vault()).to.equal(backupVault.address)
      expect(await main.fullyCapitalized()).to.equal(false)
    })


    // TODO: Handle no backup vault found
  })

 describe('Select Next Vault', () => {
    let backupVault1: VaultP0
    let backupVault2: VaultP0
    let backupVault3: VaultP0
    let backupVault4: VaultP0

    beforeEach(async function () {
      // Deploy backup vaults
      backupVault1 = <VaultP0>await VaultFactory.deploy([collateral[0]], [quantities[0]], [])
      backupVault2 = <VaultP0>(
        await VaultFactory.deploy(
          [collateral[0], collateral[1]],
          [quantities[0], quantities[1]],
          []
        )
      )
      backupVault3 = <VaultP0>(
        await VaultFactory.deploy(
          [collateral[0], collateral[1], collateral[2]],
          [quantities[0], quantities[1], quantities[2]],
          []
        )
      )
      backupVault4 = <VaultP0>(
        await VaultFactory.deploy(
          [collateral[1], collateral[2]],
          [quantities[1], quantities[2]],
          []
        )
      )

      await vault
        .connect(owner)
        .setBackups([
          backupVault1.address,
          backupVault2.address,
          backupVault3.address,
          backupVault4.address,
        ])
    })

    it('Vault should not change if there is no valid backup vault', async function () {
      // Get next vault with different token
      await defaultHandler.connect(owner).unapproveCollateral(assetAToken.address)
      await defaultHandler.poke()
      expect(await defaultHandler.vault()).to.equal(vault.address) // no change
    })

    it('Should change to a valid vault based on accepted collateral after 1 default', async function () {
      // Get the only valid vault that contains only approved collateral
      await defaultHandler.connect(owner).unapproveCollateral(collateral[0])
      await defaultHandler.poke()
      expect(await defaultHandler.vault()).to.equal(backupVault1.address) // no change
    })

    it('Should change to a valid vault based on accepted collateral after 2 defaults', async function () {
      // Get the only valid vault that contains only approved collateral
      await defaultHandler.connect(owner).unapproveCollateral(collateral[1])
      await defaultHandler.connect(owner).unapproveCollateral(collateral[2])
      await defaultHandler.poke()
      expect(await defaultHandler.vault()).to.equal(backupVault4.address) // no change
    })

    it('Should change to vault with the highest rate after 3 defaults', async function () {
      // Return the vault with highest rate (all 3 candidates are valid)
      await defaultHandler.connect(owner).unapproveCollateral(collateral[0])
      await defaultHandler.connect(owner).unapproveCollateral(collateral[1])
      await defaultHandler.connect(owner).unapproveCollateral(collateral[2])
      await defaultHandler.poke()
      expect(await defaultHandler.vault()).to.equal(backupVault3.address) // no change
    })

    it('Should change to vault with the highest rate after 2 defaults', async function () {
      // Return the vault with highest rate (all 3 candidates are valid)
      await defaultHandler.connect(owner).unapproveCollateral(collateral[0])
      await defaultHandler.connect(owner).unapproveCollateral(collateral[1])
      await defaultHandler.poke()
      expect(await defaultHandler.vault()).to.equal(backupVault2.address) // no change
    })
  })

  //  Old Asset Manager

  describe('Base Factor', () => {
    it('Should start with Base Factor = 1', async () => {
      expect(await main.toBUs(bn('1e18'))).to.equal(bn('1e18'))
      expect(await main.fromBUs(bn('1e18'))).to.equal(bn('1e18'))
    })

    context('With issued RTokens', async function () {
      let issueAmount: BigNumber

      beforeEach(async function () {
        // Issue some RTokens to user
        issueAmount = bn('100e18')
        // Provide approvals
        await token0.connect(addr1).approve(main.address, initialBal)
        await token1.connect(addr1).approve(main.address, initialBal)
        await token2.connect(addr1).approve(main.address, initialBal)
        await token3.connect(addr1).approve(main.address, initialBal)

        // Issue rTokens
        await main.connect(addr1).issue(issueAmount)

        // Process the issuance
        await main.poke()
      })

      it('Should update Base Factor based on Melting Factor', async () => {
        expect(await main.toBUs(bn('1e18'))).to.equal(bn('1e18'))
        expect(await main.fromBUs(bn('1e18'))).to.equal(bn('1e18'))

        // Melt some Rtokens
        let hndAmt: BigNumber = bn('1e18')
        await rToken.connect(addr1).transfer(furnace.address, hndAmt)
        await furnace.connect(addr1).notifyOfDeposit(rToken.address)

        // Call poke to burn tokens
        await advanceTime(config.rewardPeriod.toString())
        await main.poke()

        expect(await main.toBUs(bn('1e18'))).to.equal(bn('100e18').div(99))
        expect(await main.fromBUs(bn('1e18'))).to.equal(bn('0.99e18'))

        // Melt some more Rtokens
        hndAmt = bn('49e18')
        await rToken.connect(addr1).transfer(furnace.address, hndAmt)
        await furnace.connect(addr1).notifyOfDeposit(rToken.address)

        // Call poke to burn tokens
        await advanceTime(config.rewardPeriod.toString())
        await main.poke()

        expect(await main.toBUs(bn('1e18'))).to.equal(bn('100e18').div(50))
        expect(await main.fromBUs(bn('1e18'))).to.equal(bn('0.5e18'))
      })
    })

    context('With ATokens and CTokens', async function () {
      let issueAmount: BigNumber

      beforeEach(async function () {
        issueAmount = bn('100e18')

        // Setup new vault with ATokens and CTokens
        let newVault: VaultP0 = <VaultP0>(
          await VaultFactory.deploy(
            [collateral2.address, collateral3.address],
            [bn('0.5e18'), bn('0.5e8')],
            []
          )
        )
        // Setup Main
        await newVault.connect(owner).setMain(main.address)

        // Switch Vault
        await main.connect(owner).switchVault(newVault.address)

        // Provide approvals
        await token2.connect(addr1).approve(main.address, initialBal)
        await token3.connect(addr1).approve(main.address, initialBal)

        // Issue rTokens
        await main.connect(addr1).issue(issueAmount)

        // Process the issuance
        await main.poke()
      })

      it('Should update Base Factor based on Basket Dilution Factor', async () => {
        expect(await main.toBUs(bn('1e18'))).to.equal(bn('1e18'))
        expect(await main.fromBUs(bn('1e18'))).to.equal(bn('1e18'))

        // Increase rate for ATokens CToken to double - 100% increase so a 60% applies to base factor (based on f)
        await token2.setExchangeRate(fp(2))
        await token3.setExchangeRate(fp(2))

        // f = fp(0.6) = 40% increase in price of RToken -> (1 + 0.4) / 2 = 7/10
        let b = fp(1)
          .add(bn(2 - 1).mul(fp(1).sub(dist.rsrDist)))
          .div(bn(2))
        expect(await main.toBUs(bn('1e18'))).to.equal(b)
        expect(await main.fromBUs(bn('1e18'))).to.equal(fp('1e18').div(b))

        // Double again (300% increase)
        await token2.setExchangeRate(fp(4))
        await token3.setExchangeRate(fp(4))

        // f = fp(0.6) - 60% of 300% increase = 180% increase in price of RToken -> (1 + 1.8) / 4 = 7/10
        b = fp(1)
          .add(bn(4 - 1).mul(fp(1).sub(dist.rsrDist)))
          .div(bn(4))
        expect(await main.toBUs(bn('1e18'))).to.equal(b)
        expect(await main.fromBUs(bn('1e18'))).to.equal(fp('1e18').div(b))
      })
    })
  })
})
