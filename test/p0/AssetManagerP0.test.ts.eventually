import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers'
import { expect } from 'chai'
import { BigNumber, ContractFactory, Wallet } from 'ethers'
import { ethers, waffle } from 'hardhat'

import { BN_SCALE_FACTOR, MAX_UINT256 } from '../../common/constants'
import { bn, fp } from '../../common/numbers'
import { AAVEAssetP0 } from '../../typechain/AAVEAssetP0'
import { AaveLendingPoolMockP0 } from '../../typechain/AaveLendingPoolMockP0'
import { AaveOracleMockP0 } from '../../typechain/AaveOracleMockP0'
import { AssetManagerP0 } from '../../typechain/AssetManagerP0'
import { ATokenFiatCollateralP0 } from '../../typechain/ATokenFiatCollateralP0'
import { CollateralP0 } from '../../typechainFiatCollateralP0'
import { COMPAssetP0 } from '../../typechain/COMPAssetP0'
import { CompoundOracleMockP0 } from '../../typechain/CompoundOracleMockP0'
import { ComptrollerMockP0 } from '../../typechain/ComptrollerMockP0'
import { CTokenFiatCollateralP0 } from '../../typechain/CTokenFiatCollateralP0'
import { CTokenMock } from '../../typechain/CTokenMock'
import { DefaultMonitorP0 } from '../../typechain/DefaultMonitorP0'
import { DeployerP0 } from '../../typechain/DeployerP0'
import { ERC20Mock } from '../../typechain/ERC20Mock'
import { FurnaceP0 } from '../../typechain/FurnaceP0'
import { MainP0 } from '../../typechain/MainP0'
import { MarketMock } from '../../typechain/MarketMock'
import { RSRAssetP0 } from '../../typechain/RSRAssetP0'import { RTokenAssetP0 } from '../../typechain/RTokenAssetP0'
import { RTokenP0 } from '../../typechain/RTokenP0'
import { StaticATokenMock } from '../../typechain/StaticATokenMock'
import { StRSRP0 } from '../../typechain/StRSRP0'
import { VaultP0 } from '../../typechain/VaultP0'
import { advanceTime, getLatestBlockTimestamp } from '../utils/time'
import { defaultFixture, Fate, IConfig, State } from './utils/fixtures'

const createFixtureLoader = waffle.createFixtureLoader

describe('AssetManagerP0 contract', () => {
  let owner: SignerWithAddress
  let addr1: SignerWithAddress
  let other: SignerWithAddress

  // Deployer contract
  let deployer: DeployerP0

  // Vault and Assets
  let VaultFactory: ContractFactory
  let vault: VaultP0
  let collateral: string[]

  // AssetManager
  let AssetManagerFactory: ContractFactory

  // RSR
  let rsr: ERC20Mock
  let rsrAsset: RSRAssetP0

  // AAVE and Compound
  let compToken: ERC20Mock
  let compAsset: COMPAssetP0
  let compoundMock: ComptrollerMockP0
  let compoundOracle: CompoundOracleMockP0
  let aaveToken: ERC20Mock
  let aaveAsset: AAVEAssetP0
  let aaveMock: AaveLendingPoolMockP0
  let aaveOracle: AaveOracleMockP0

  // Tokens and Assets
  let initialBal: BigNumber
  let qtyHalf: BigNumber
  let qtyThird: BigNumber
  let qtyDouble: BigNumber

  let token0: ERC20Mock
  let token1: ERC20Mock
  let token2: ERC20Mock
  let token3: ERC20Mock
  let collateral0: CollateralP0
  let collateral1: CollateralP0
  let collateral2: CollateralP0
  let collateral3: CollateralP0
  let ATokenMockFactory: ContractFactory
  let ATokenAssetFactory: ContractFactory
  let aToken: StaticATokenMock
  let assetAToken: ATokenFiatCollateralP0
  let CTokenMockFactory: ContractFactory
  let CTokenAssetFactory: ContractFactory
  let cToken: CTokenMock
  let assetCToken: CTokenFiatCollateralP0

  // Config values
  let config: IConfig

  // Contracts to retrieve after deploy
  let rToken: RTokenP0
  let stRSR: StRSRP0
  let furnace: FurnaceP0
  let main: MainP0
  let assetManager: AssetManagerP0
  let defaultMonitor: DefaultMonitorP0
  let trading: MarketMock

  let loadFixture: ReturnType<typeof createFixtureLoader>
  let wallet: Wallet


  before('create fixture loader', async () => {
    ;[wallet] = await (ethers as any).getSigners()
    loadFixture = createFixtureLoader([wallet])
  })

  beforeEach(async () => {
    ;[owner, addr1, other] = await ethers.getSigners()

    // Deploy fixture
    ;({
      rsr,
      rsrAsset,
      compToken,
      aaveToken,
      compAsset,
      aaveAsset,
      compoundOracle,
      aaveOracle,
      compoundMock,
      aaveMock,
      token0,
      token1,
      token2,
      token3,
      collateral0,
      collateral1,
      collateral2,
      collateral3,
      collateral,
      vault,
      config,
      deployer,
      main,
      rToken,
      furnace,
      stRSR,
      assetManager,
      defaultMonitor,
      trading,
    } = await loadFixture(defaultFixture))

    // Mint initial balances
    initialBal = bn('100000e18')
    qtyHalf = bn('1e18').div(2)
    qtyThird = bn('1e18').div(3)
    qtyDouble = bn('1e18').mul(2)
    await token0.connect(owner).mint(addr1.address, initialBal)
    await token1.connect(owner).mint(addr1.address, initialBal)
    await token2.connect(owner).mint(addr1.address, initialBal)
    await token3.connect(owner).mint(addr1.address, initialBal)

    // ATokens and CTokens
    ATokenMockFactory = await ethers.getContractFactory('StaticATokenMock')
    aToken = <StaticATokenMock>await ATokenMockFactory.deploy('AToken', 'ATKN0', token0.address)
    await aToken.setAaveToken(aaveToken.address)
    ATokenAssetFactory = await ethers.getContractFactory('ATokenFiatCollateralP0')
    assetAToken = <ATokenFiatCollateralP0>(
      await ATokenAssetFactory.deploy(aToken.address, aToken.decimals())
    )

    CTokenMockFactory = await ethers.getContractFactory('CTokenMock')
    cToken = <CTokenMock>await CTokenMockFactory.deploy('CToken', 'CTKN1', token1.address)
    CTokenAssetFactory = await ethers.getContractFactory('CTokenFiatCollateralP0')
    assetCToken = <CTokenFiatCollateralP0>(
      await CTokenAssetFactory.deploy(cToken.address, cToken.decimals())
    )

    // Mint ATokens and CTokens
    await aToken.connect(owner).mint(addr1.address, initialBal)
    await cToken.connect(owner).mint(addr1.address, initialBal)

    // Set Vault Factory (for creating additional vaults in tests)
    VaultFactory = await ethers.getContractFactory('VaultP0')

    // Setup Main
    await vault.connect(owner).setMain(main.address)
  })

  // Note: Issuance, Redemption, and Vault management are tested as part of MainP0


  describe('Recapitalization', () => {
    context('With very simple Basket - Single stablecoin', async function () {
      let issueAmount: BigNumber
      let backupVault: VaultP0
      let defVault: VaultP0
      let rTokenAsset: RTokenAssetP0

      beforeEach(async function () {
        // For simple vault with one token (1 to 1) - And backup
        backupVault = <VaultP0>await VaultFactory.deploy([collateral[1]], [bn('1e18')], [])
        defVault = <VaultP0>await VaultFactory.deploy([collateral[0]], [bn('1e18')], [backupVault.address])

        // Setup Main
        await defVault.connect(owner).setMain(main.address)

        // Switch Vault
        await assetManager.connect(owner).switchVault(defVault.address)

        // Issue some RTokens to user
        issueAmount = bn('100e18')
        // Provide approvals
        await token0.connect(addr1).approve(main.address, initialBal)

        // Issue rTokens
        await main.connect(addr1).issue(issueAmount)

        // Process the issuance
        await main.poke()

        // Get RToken Asset
        rTokenAsset = <RTokenAssetP0>await ethers.getContractAt('RTokenAssetP0', await main.rTokenAsset())
      })

      it('Should recapitalize correctly in case of switching vault', async () => {
        // Define a new vault
        const newVault: VaultP0 = <VaultP0>await VaultFactory.deploy([collateral[1]], [bn('1e18')], [])
        await newVault.connect(owner).setMain(main.address)

        // Set Max auction to 100%  and migration chunk to 100% to do it in one single redemption and auction
        const newConfig: IConfig = {
          rewardStart: config.rewardStart,
          rewardPeriod: config.rewardPeriod,
          auctionPeriod: config.auctionPeriod,
          stRSRWithdrawalDelay: config.stRSRWithdrawalDelay,
          defaultDelay: config.defaultDelay,
          maxTradeSlippage: config.maxTradeSlippage,
          maxAuctionSize: fp('1'), //100%
          minRecapitalizationAuctionSize: config.minRecapitalizationAuctionSize,
          minRevenueAuctionSize: config.minRevenueAuctionSize,
          migrationChunk: fp('1'), // 100%
          issuanceRate: config.issuanceRate,
          defaultThreshold: config.defaultThreshold,
          f: config.f,
        }

        // Update config
        await main.connect(owner).setConfig(newConfig)

        // Check initial state
        expect(await main.state()).to.equal(State.CALM)
        expect(await assetManager.vault()).to.equal(defVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(true)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount)
        expect(await token1.balanceOf(newVault.address)).to.equal(0)
        expect(await newVault.basketUnits(assetManager.address)).to.equal(0)

        // Check price in USD of the current RToken
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))

        // Switch Vault
        await expect(assetManager.connect(owner).switchVault(newVault.address)).to.not.emit(
          assetManager,
          'AuctionStarted'
        )

        // Check state remains CALM
        expect(await main.state()).to.equal(State.CALM)
        expect(await assetManager.vault()).to.equal(newVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount)
        expect(await token1.balanceOf(newVault.address)).to.equal(0)
        expect(await newVault.basketUnits(assetManager.address)).to.equal(0)

        // Notice vault change and trigger recapitalization
        // Will create auction, based on config, all balance will be redeemed
        let sellAmt: BigNumber = await token0.balanceOf(defVault.address)
        let buyAmtBid: BigNumber = sellAmt.sub(sellAmt.div(100)) // based on trade slippage

        await expect(main.poke())
          .to.emit(main, 'SystemStateChanged')
          .withArgs(State.CALM, State.TRADING)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, buyAmtBid, Fate.Stay)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(newVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0) // All sent to auction/market
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(newVault.address)).to.equal(0) // Nothing came from the auction yet
        expect(await newVault.basketUnits(assetManager.address)).to.equal(0)

        // Check auction created
        expectAuctionInfo(0, {
          sell: collateral0.address,
          buy: collateral1.address,
          sellAmount: sellAmt,
          minBuyAmount: buyAmtBid,
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Stay,
          isOpen: true,
        })

        // Another call should not create any new auctions if still ongoing
        await expect(main.poke()).to.not.emit(assetManager, 'AuctionStarted')
        expect(await main.state()).to.equal(State.TRADING)

        // Perform Mock Bids for the new Token (addr1 has balance)
        // Get fair price - all tokens
        await token1.connect(addr1).approve(trading.address, sellAmt)
        await trading.placeBid(0, { bidder: addr1.address, sellAmount: sellAmt, buyAmount: sellAmt })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should  not start any new auctions
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, sellAmt, Fate.Stay)
          .and.to.not.emit(assetManager, 'AuctionStarted')

        // Check previous auction is closed
        expectAuctionOpen(0, false)

        // Check state
        expect(await main.state()).to.equal(State.CALM)
        expect(await assetManager.vault()).to.equal(newVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(true)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(newVault.address)).to.equal(issueAmount) // All funds obtained
        expect(await newVault.basketUnits(assetManager.address)).to.equal(issueAmount)

        // Check price in USD of the current RToken is maintained
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))
      })

      it('Should recapitalize correctly in case of default - Taking Haircut', async () => {
        // Set Max auction  and migration chunk to 50%
        const newConfig: IConfig = {
          rewardStart: config.rewardStart,
          rewardPeriod: config.rewardPeriod,
          auctionPeriod: config.auctionPeriod,
          stRSRWithdrawalDelay: config.stRSRWithdrawalDelay,
          defaultDelay: config.defaultDelay,
          maxTradeSlippage: config.maxTradeSlippage,
          maxAuctionSize: fp('0.5'), // 50%
          minRecapitalizationAuctionSize: config.minRecapitalizationAuctionSize,
          minRevenueAuctionSize: config.minRevenueAuctionSize,
          migrationChunk: fp('0.5'), // 50%
          issuanceRate: config.issuanceRate,
          defaultThreshold: config.defaultThreshold,
          f: config.f,
        }

        // Update config
        await main.connect(owner).setConfig(newConfig)

        // Check price in USD of the current RToken
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))

        // Set Token0 to default - 50% price reduction
        await aaveOracle.setPrice(token0.address, bn('1.25e14'))

        // Check initial state
        expect(await main.state()).to.equal(State.CALM)

        // Running auctions will not trigger recapitalization until default flag is up
        await expect(main.poke()).to.not.emit(assetManager, 'AuctionStarted')

        // Notice default
        await expect(main.noticeDefault())
          .to.emit(main, 'SystemStateChanged')
          .withArgs(State.CALM, State.DOUBT)

        // Check initial state
        expect(await main.state()).to.equal(State.DOUBT)

        // Cannot run again poke during Doubt state
        await expect(main.poke()).to.be.revertedWith('only during calm + trading')

        // Advance time post defaultDelay
        await advanceTime(config.defaultDelay.toString())

        await expect(main.noticeDefault())
          .to.emit(main, 'SystemStateChanged')
          .withArgs(State.DOUBT, State.TRADING)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount)
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(0)

        // Based on Migration chunk parameter 50% of balance will be redeemed
        let sellAmt: BigNumber = (await token0.balanceOf(defVault.address)).div(2)

        // Now run recapitalization auction
        // BuyAmount = 0 when token is defaulted
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionStarted')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, bn('0'), Fate.Stay)

        // Check auction created
        expectAuctionInfo(0, {
          sell: collateral0.address,
          buy: collateral1.address,
          sellAmount: sellAmt,
          minBuyAmount: bn('0'),
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Stay,
          isOpen: true,
        })

        // Another call should not create any new auctions if still ongoing
        await expect(main.poke()).to.not.emit(assetManager, 'AuctionStarted')
        expect(await main.state()).to.equal(State.TRADING)

        // Check existing auction still open
        expectAuctionOpen(0, true)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount.sub(sellAmt))
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount.sub(sellAmt))
        expect(await token1.balanceOf(backupVault.address)).to.equal(0)
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(0)

        // Perform Mock Bids for the new Token (addr1 has balance)
        // Assume fair price, get half of the tokens (because price reduction was 50%)
        const buyAmtBid: BigNumber = sellAmt.div(2)
        await token1.connect(addr1).approve(trading.address, buyAmtBid)
        await trading.placeBid(0, { bidder: addr1.address, sellAmount: sellAmt, buyAmount: buyAmtBid })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should start a new one with same amount
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, buyAmtBid, Fate.Stay)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(1, collateral0.address, collateral1.address, sellAmt, bn('0'), Fate.Stay)

        // Check previous auction is closed
        expectAuctionOpen(0, false)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount.sub(sellAmt.mul(2)))
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount.sub(sellAmt.mul(2)))
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid)
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid)

        // Check new auction
        expectAuctionInfo(1, {
          sell: collateral0.address,
          buy: collateral1.address,
          sellAmount: sellAmt,
          minBuyAmount: bn('0'),
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Stay,
          isOpen: true,
        })

        // Perform Mock Bids for the new Token (addr1 has balance)
        // Assume fair price, get half of the tokens (because price reduction was 50%)
        await token1.connect(addr1).approve(trading.address, buyAmtBid)
        await trading.placeBid(1, { bidder: addr1.address, sellAmount: sellAmt, buyAmount: buyAmtBid })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should start a new one with same amount
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(1, collateral0.address, collateral1.address, sellAmt, buyAmtBid, Fate.Stay)
          .and.to.not.emit(assetManager, 'AuctionStarted')

        // Check auctions are closed
        expectAuctionOpen(0, false)
        expectAuctionOpen(1, false)

        // Check state
        expect(await main.state()).to.equal(State.CALM)
        expect(await assetManager.fullyCapitalized()).to.equal(true)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount.sub(sellAmt.mul(2)))
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount.sub(sellAmt.mul(2)))
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid.mul(2))
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid.mul(2))

        // Check Rtoken price is now half the original price
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1').div(2))
      })

      it('Should recapitalize correctly in case of default - Using RSR for remainder', async () => {
        // Save current RToken Supply
        const startingTotalSupply: BigNumber = await rToken.totalSupply()

        // Mint some RSR
        await rsr.connect(owner).mint(addr1.address, initialBal)

        // Perform stake
        const stkAmount: BigNumber = bn('100e18')
        await rsr.connect(addr1).approve(stRSR.address, stkAmount)
        await stRSR.connect(addr1).stake(stkAmount)

        // Check stakes
        expect(await rsr.balanceOf(stRSR.address)).to.equal(stkAmount)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(stkAmount)

        // Check RToken supply
        expect(await rToken.totalSupply()).to.equal(issueAmount)

        // Set Max auction to 25% and migration chunk to 100% (so everything is redeemd at once)
        const newConfig: IConfig = {
          rewardStart: config.rewardStart,
          rewardPeriod: config.rewardPeriod,
          auctionPeriod: config.auctionPeriod,
          stRSRWithdrawalDelay: config.stRSRWithdrawalDelay,
          defaultDelay: config.defaultDelay,
          maxTradeSlippage: config.maxTradeSlippage,
          maxAuctionSize: fp('0.25'), // 25%
          minRecapitalizationAuctionSize: config.minRecapitalizationAuctionSize,
          minRevenueAuctionSize: config.minRevenueAuctionSize,
          migrationChunk: fp('1'), // 100% - Migrate all together
          issuanceRate: config.issuanceRate,
          defaultThreshold: config.defaultThreshold,
          f: config.f,
        }

        // update config
        await main.connect(owner).setConfig(newConfig)

        // Check price in USD of the current RToken
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))

        // Set Token0 to default - 50% price reduction
        await aaveOracle.setPrice(token0.address, bn('1.25e14'))

        // Check initial state
        expect(await main.state()).to.equal(State.CALM)

        // Notice default
        await expect(main.noticeDefault()).to.emit(main, 'SystemStateChanged').withArgs(State.CALM, State.DOUBT)

        // Check state
        expect(await main.state()).to.equal(State.DOUBT)
        expect(await assetManager.vault()).to.equal(defVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(true)

        // Advance time post defaultDelay
        await advanceTime(config.defaultDelay.toString())

        await expect(main.noticeDefault()).to.emit(main, 'SystemStateChanged').withArgs(State.DOUBT, State.TRADING)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount)
        expect(await token1.balanceOf(backupVault.address)).to.equal(0)
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(0)

        // Set expected auction amount - Based on Migration chunk of 100% but using 50% max auction size
        let sellAmt: BigNumber = (await token0.balanceOf(defVault.address)).div(2)

        // Run recapitalization auction
        // Buy amount = 0 when token is defaulted
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionStarted')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, bn('0'), Fate.Stay)

        // Check new auction created
        expectAuctionInfo(0, {
          sell: collateral0.address,
          buy: collateral1.address,
          sellAmount: sellAmt,
          minBuyAmount: bn('0'),
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Stay,
          isOpen: true,
        })

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0) // Everything was sent to auction (market)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0) // All was redeemed
        expect(await token1.balanceOf(backupVault.address)).to.equal(0) // Nothing obtained from auction yet
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(0)

        // Check RToken supply - Unchanged
        expect(await rToken.totalSupply()).to.equal(issueAmount)

        // Perform Mock Bids (addr1 has balance)
        // Assume fair price, get half of the tokens (because price reduction was 50%)
        let buyAmtBid: BigNumber = sellAmt.div(2)
        await token1.connect(addr1).approve(trading.address, buyAmtBid)
        await trading.placeBid(0, { bidder: addr1.address, sellAmount: sellAmt, buyAmount: buyAmtBid })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should start a new one with same amount
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, buyAmtBid, Fate.Stay)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(1, collateral0.address, collateral1.address, sellAmt, bn('0'), Fate.Stay)

        // Check first auction is closed
        expectAuctionOpen(0, false)

        // Check new auction
        expectAuctionInfo(1, {
          sell: collateral0.address,
          buy: collateral1.address,
          sellAmount: sellAmt,
          minBuyAmount: bn('0'),
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Stay,
          isOpen: true,
        })

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid) // Amount obtained from auction
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid) // Already issued BUs based from auction

        // Check RToken supply - Unchanged
        expect(await rToken.totalSupply()).to.equal(issueAmount)

        // Perform Mock Bids (addr1 has balance)
        // Assume fair price, get half of the tokens (because price reduction was 50%)
        await token1.connect(addr1).approve(trading.address, buyAmtBid)
        await trading.placeBid(1, { bidder: addr1.address, sellAmount: sellAmt, buyAmount: buyAmtBid })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Check staking situation remains unchanged
        expect(await rsr.balanceOf(stRSR.address)).to.equal(stkAmount)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(stkAmount)

        // Call poke to end current auction, should start a new one seizing RSR for RToken - Need a total of 50e18 RTokens
        // Expected amount to be based max auction size (25e18 because RSR price = 1)
        let sellAmtRSR: BigNumber = sellAmt.div(2)
        let buyAmtBidRSR: BigNumber = sellAmtRSR.sub(sellAmtRSR.div(100)) // Due to trade slippage 1%
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(1, collateral0.address, collateral1.address, sellAmt, buyAmtBid, Fate.Stay)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(2, rsrAsset.address, rTokenAsset.address, sellAmtRSR, buyAmtBidRSR, Fate.Burn)

        // Check new auction
        expectAuctionInfo(2, {
          sell: rsrAsset.address,
          buy: rTokenAsset.address,
          sellAmount: sellAmtRSR,
          minBuyAmount: buyAmtBidRSR,
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Burn,
          isOpen: true,
        })

        // Check previous auctions are closed
        expectAuctionOpen(0, false)
        expectAuctionOpen(1, false)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid.mul(2)) // Received from both auctions
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid.mul(2)) // All issued from both auctions

        // Should have seized RSR
        expect(await rsr.balanceOf(stRSR.address)).to.equal(stkAmount.sub(sellAmtRSR)) // Sent to market (auction)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(stkAmount.sub(sellAmtRSR)) // Seized from user

        // Check RToken supply - Unchanged
        expect(await rToken.totalSupply()).to.equal(issueAmount)

        // Perform Mock Bids for RSR (addr1 has balance)
        // Assume fair price RSR = 1 to 1 - Get all of them
        await rToken.connect(addr1).approve(trading.address, sellAmtRSR)
        await trading.placeBid(2, {
          bidder: addr1.address,
          sellAmount: sellAmtRSR,
          buyAmount: sellAmtRSR,
        })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should start a new one with remaining RSR to seize
        // Will apply max auction size (25%) over the new RToken supply of 75e18 (100e18 - 25e18) = 18.75e18
        let sellAmtRSRRemain: BigNumber = (await rToken.totalSupply()).sub(sellAmtRSR).mul(25).div(100)
        let buyAmtBidRSRRemain: BigNumber = sellAmtRSRRemain.sub(sellAmtRSRRemain.div(100)) // Due to trade slippage 1%

        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(2, rsrAsset.address, rTokenAsset.address, sellAmtRSR, sellAmtRSR, Fate.Burn)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(3, rsrAsset.address, rTokenAsset.address, sellAmtRSRRemain, buyAmtBidRSRRemain, Fate.Burn)

        // Check new auction
        expectAuctionInfo(3, {
          sell: rsrAsset.address,
          buy: rTokenAsset.address,
          sellAmount: sellAmtRSRRemain,
          minBuyAmount: buyAmtBidRSRRemain,
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Burn,
          isOpen: true,
        })

        // Check previous auctions are closed
        expectAuctionOpen(0, false)
        expectAuctionOpen(1, false)
        expectAuctionOpen(2, false)

        // Should have seized RSR
        expect(await rsr.balanceOf(stRSR.address)).to.equal(stkAmount.sub(sellAmtRSR).sub(sellAmtRSRRemain)) // Sent to market (auction)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(stkAmount.sub(sellAmtRSR).sub(sellAmtRSRRemain)) // Seized from user

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid.mul(2))
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid.mul(2))

        // Check RToken supply - Should have burnt the obtained amount from auctions
        expect(await rToken.totalSupply()).to.equal(issueAmount.sub(sellAmtRSR))

        // Perform Mock Bids for RSR (addr1 has balance)
        // Assume fair price RSR = 1 to 1 - Get all of them
        await rToken.connect(addr1).approve(trading.address, sellAmtRSRRemain)
        await trading.placeBid(3, {
          bidder: addr1.address,
          sellAmount: sellAmtRSRRemain,
          buyAmount: sellAmtRSRRemain,
        })
        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should start a new one with remaining RSR to seize
        // Only 6.25e18 Tokens left to buy (50e18 - (25e18 + 18.75e18)) = 6.25e18
        // Note:  Sets Buy amount as independent value - Check if this has to be done in previous RSR auctions (Potential issue)
        let buyAmtBidRSRFinal: BigNumber = sellAmt.sub(sellAmtRSR).sub(sellAmtRSRRemain)
        let sellAmtRSRFinal: BigNumber = buyAmtBidRSRFinal.add(buyAmtBidRSRFinal.div(100)) // Due to trade slippage 1%

        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(3, rsrAsset.address, rTokenAsset.address, sellAmtRSRRemain, sellAmtRSRRemain, Fate.Burn)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(4, rsrAsset.address, rTokenAsset.address, sellAmtRSRFinal, buyAmtBidRSRFinal, Fate.Burn)

        // Check new auction
        expectAuctionInfo(4, {
          sell: rsrAsset.address,
          buy: rTokenAsset.address,
          sellAmount: sellAmtRSRFinal,
          minBuyAmount: buyAmtBidRSRFinal,
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Burn,
          isOpen: true,
        })

        // Check previous auctions are closed
        expectAuctionOpen(0, false)
        expectAuctionOpen(1, false)
        expectAuctionOpen(2, false)
        expectAuctionOpen(3, false)

        // Should have seized RSR
        expect(await rsr.balanceOf(stRSR.address)).to.equal(
          stkAmount.sub(sellAmtRSR).sub(sellAmtRSRRemain).sub(sellAmtRSRFinal)
        ) // Sent to market (auction)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(
          stkAmount.sub(sellAmtRSR).sub(sellAmtRSRRemain).sub(sellAmtRSRFinal)
        ) // Seized from user

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid.mul(2))
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid.mul(2))

        // Check RToken supply - Should have burnt the obtained amount from auctions
        expect(await rToken.totalSupply()).to.equal(issueAmount.sub(sellAmtRSR).sub(sellAmtRSRRemain))

        // Perform Mock Bids for RSR (addr1 has balance)
        // Assume fair price RSR = 1 to 1 - Get all of them
        await rToken.connect(addr1).approve(trading.address, buyAmtBidRSRFinal)
        await trading.placeBid(4, {
          bidder: addr1.address,
          sellAmount: buyAmtBidRSRFinal,
          buyAmount: buyAmtBidRSRFinal,
        })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call auction to be processed
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(4, rsrAsset.address, rTokenAsset.address, buyAmtBidRSRFinal, buyAmtBidRSRFinal, Fate.Burn)
          .and.not.to.emit(assetManager, 'AuctionStarted')

        // Check previous auctions are closed
        expectAuctionOpen(0, false)
        expectAuctionOpen(1, false)
        expectAuctionOpen(2, false)
        expectAuctionOpen(3, false)
        expectAuctionOpen(4, false)

        // Check final state - All traded OK
        expect(await main.state()).to.equal(State.CALM)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(true)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(buyAmtBid.mul(2))
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(buyAmtBid.mul(2))

        // Check RToken supply - Should have burnt the obtained amount from auctions
        // It should at the end be half of the original supply (because we took a 50% reduction in collateral)
        expect(await rToken.totalSupply()).to.equal(
          issueAmount.sub(sellAmtRSR).sub(sellAmtRSRRemain).sub(buyAmtBidRSRFinal)
        )
        expect(await rToken.totalSupply()).to.equal(startingTotalSupply.div(2))

        // Check Rtoken price is stable
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))
      })
    })

    context('With more complex Basket - Multiple stablecoins', async function () {
      let issueAmount: BigNumber
      let backupVault: VaultP0
      let defVault: VaultP0
      let rTokenAsset: RTokenAssetP0

      beforeEach(async function () {
        // A bit more complex vault with two tokens - And backup
        backupVault = <VaultP0>await VaultFactory.deploy([collateral[1]], [bn('1e18')], [])
        defVault = <VaultP0>(
          await VaultFactory.deploy([collateral[0], collateral[1]], [qtyHalf, qtyHalf], [backupVault.address])
        )

        // Setup Main
        await defVault.connect(owner).setMain(main.address)

        // Switch Vault
        await assetManager.connect(owner).switchVault(defVault.address)

        // Issue some RTokens to user
        issueAmount = bn('100e18')
        // Provide approvals
        await token0.connect(addr1).approve(main.address, initialBal)
        await token1.connect(addr1).approve(main.address, initialBal)

        // Issue rTokens
        await main.connect(addr1).issue(issueAmount)

        // Process the issuance
        await main.poke()

        // Get RToken Asset
        rTokenAsset = <RTokenAssetP0>await ethers.getContractAt('RTokenAssetP0', await main.rTokenAsset())
      })

      it('Should recapitalize correctly in case of default - Using RSR for remainder', async () => {
        // Save current RToken Supply
        const startingTotalSupply: BigNumber = await rToken.totalSupply()

        // Mint some RSR
        await rsr.connect(owner).mint(addr1.address, initialBal)

        // Perform stake
        const stkAmount: BigNumber = bn('100e18')
        await rsr.connect(addr1).approve(stRSR.address, stkAmount)
        await stRSR.connect(addr1).stake(stkAmount)

        // Check stakes
        expect(await rsr.balanceOf(stRSR.address)).to.equal(stkAmount)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(stkAmount)

        // Check RToken supply
        expect(await rToken.totalSupply()).to.equal(issueAmount)

        // Check Rtoken price is stable
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))

        // Set Max auction to 80% and migration chunk to 100% (so everything is redeemd at once)
        const newConfig: IConfig = {
          rewardStart: config.rewardStart,
          rewardPeriod: config.rewardPeriod,
          auctionPeriod: config.auctionPeriod,
          stRSRWithdrawalDelay: config.stRSRWithdrawalDelay,
          defaultDelay: config.defaultDelay,
          maxTradeSlippage: config.maxTradeSlippage,
          maxAuctionSize: fp('0.8'), // 25%
          minRecapitalizationAuctionSize: config.minRecapitalizationAuctionSize,
          minRevenueAuctionSize: config.minRevenueAuctionSize,
          migrationChunk: fp('1'), // 100% - Migrate all together
          issuanceRate: config.issuanceRate,
          defaultThreshold: config.defaultThreshold,
          f: config.f,
        }

        // Update config
        await main.connect(owner).setConfig(newConfig)

        // Set Token0 to default - 50% price reduction
        await aaveOracle.setPrice(token0.address, bn('1.25e14'))

        // Check initial state
        expect(await main.state()).to.equal(State.CALM)

        // Notice default
        await expect(main.noticeDefault()).to.emit(main, 'SystemStateChanged').withArgs(State.CALM, State.DOUBT)

        // Check state
        expect(await main.state()).to.equal(State.DOUBT)
        expect(await assetManager.vault()).to.equal(defVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(true)

        // Advance time post defaultDelay
        await advanceTime(config.defaultDelay.toString())

        await expect(main.noticeDefault()).to.emit(main, 'SystemStateChanged').withArgs(State.DOUBT, State.TRADING)

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(issueAmount.div(2))
        expect(await token1.balanceOf(defVault.address)).to.equal(issueAmount.div(2))
        expect(await defVault.basketUnits(assetManager.address)).to.equal(issueAmount)
        // New vault
        expect(await token0.balanceOf(backupVault.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(0)
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(0)

        // Set expected auction amount - Can auction the full amount
        let sellAmt: BigNumber = await token0.balanceOf(defVault.address)

        // Run recapitalization auction
        // Buy amount = 0 when token is defaulted
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionStarted')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, bn('0'), Fate.Stay)

        // Check new auction created
        expectAuctionInfo(0, {
          sell: collateral0.address,
          buy: collateral1.address,
          sellAmount: sellAmt,
          minBuyAmount: bn('0'),
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Stay,
          isOpen: true,
        })

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0) // Everything was sent to auction
        expect(await token1.balanceOf(defVault.address)).to.equal(0) // Everything redeemed from vault
        expect(await token1.balanceOf(assetManager.address)).to.equal(issueAmount.div(2)) // Balance now in AssetManager
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0) // All was redeemed
        // New vault
        expect(await token0.balanceOf(backupVault.address)).to.equal(0) // Nothing obtained from auction yet
        expect(await token1.balanceOf(backupVault.address)).to.equal(0)
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(0)

        // Check RToken supply - Unchanged
        expect(await rToken.totalSupply()).to.equal(issueAmount)

        // Perform Mock Bids (addr1 has balance)
        // Assume fair price, get 90% of the tokens required
        let buyAmtBid: BigNumber = sellAmt.mul(90).div(100)
        await token1.connect(addr1).approve(trading.address, buyAmtBid)
        await trading.placeBid(0, { bidder: addr1.address, sellAmount: sellAmt, buyAmount: buyAmtBid })

        // Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        // Call poke to end current auction, should start a new one for RSR to seize
        // Note:  Sets Buy amount as independent value
        let buyAmtBidRSRFinal: BigNumber = sellAmt.sub(buyAmtBid)
        let sellAmtRSRFinal: BigNumber = buyAmtBidRSRFinal.add(buyAmtBidRSRFinal.div(100)) // Due to trade slippage 1%

        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(0, collateral0.address, collateral1.address, sellAmt, buyAmtBid, Fate.Stay)
          .and.to.emit(assetManager, 'AuctionStarted')
          .withArgs(1, rsrAsset.address, rTokenAsset.address, sellAmtRSRFinal, buyAmtBidRSRFinal, Fate.Burn)

        // Check new auction
        expectAuctionInfo(1, {
          sell: rsrAsset.address,
          buy: rTokenAsset.address,
          sellAmount: sellAmtRSRFinal,
          minBuyAmount: buyAmtBidRSRFinal,
          startTime: await getLatestBlockTimestamp(),
          endTime: (await getLatestBlockTimestamp()) + Number(config.auctionPeriod),
          clearingSellAmount: bn('0'),
          clearingBuyAmount: bn('0'),
          fate: Fate.Burn,
          isOpen: true,
        })

        // Check previous auctions are closed
        expectAuctionOpen(0, false)

        // Should have seized RSR
        expect(await rsr.balanceOf(stRSR.address)).to.equal(stkAmount.sub(sellAmtRSRFinal)) // Sent to market (auction)
        expect(await stRSR.balanceOf(addr1.address)).to.equal(stkAmount.sub(sellAmtRSRFinal)) // Seized from user

        // Check state
        expect(await main.state()).to.equal(State.TRADING)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(false)
        expect(await token0.balanceOf(defVault.address)).to.equal(0) // Everything was sent to auction
        expect(await token1.balanceOf(defVault.address)).to.equal(0)
        expect(await token1.balanceOf(assetManager.address)).to.equal(0) // Balance now in new vault
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0) // All was redeemed
        // New vault
        expect(await token0.balanceOf(backupVault.address)).to.equal(0) // Nothing obtained from auction yet
        expect(await token1.balanceOf(backupVault.address)).to.equal(issueAmount.div(2).add(buyAmtBid)) // Moved from asset manager + bid
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(issueAmount.div(2).add(buyAmtBid))

        // Perform Mock Bids for RSR (addr1 has balance)
        // Assume fair price RSR = 1 to 1 - Get all of them
        await rToken.connect(addr1).approve(trading.address, buyAmtBidRSRFinal)
        await trading.placeBid(1, {
          bidder: addr1.address,
          sellAmount: buyAmtBidRSRFinal,
          buyAmount: buyAmtBidRSRFinal,
        })

        //  Advance time till auction ended
        await advanceTime(newConfig.auctionPeriod.add(100).toString())

        //  Call auction to be processed
        await expect(main.poke())
          .to.emit(assetManager, 'AuctionEnded')
          .withArgs(1, rsrAsset.address, rTokenAsset.address, buyAmtBidRSRFinal, buyAmtBidRSRFinal, Fate.Burn)
          .and.not.to.emit(assetManager, 'AuctionStarted')

        //  Check previous auctions are closed
        expectAuctionOpen(0, false)
        expectAuctionOpen(1, false)

        // Check state - All traded OK
        expect(await main.state()).to.equal(State.CALM)
        expect(await assetManager.vault()).to.equal(backupVault.address)
        expect(await assetManager.fullyCapitalized()).to.equal(true)
        expect(await token0.balanceOf(defVault.address)).to.equal(0)
        expect(await token1.balanceOf(defVault.address)).to.equal(0)
        expect(await token1.balanceOf(assetManager.address)).to.equal(0)
        expect(await defVault.basketUnits(assetManager.address)).to.equal(0)
        // New vault
        expect(await token0.balanceOf(backupVault.address)).to.equal(0)
        expect(await token1.balanceOf(backupVault.address)).to.equal(issueAmount.div(2).add(buyAmtBid)) // Moved from asset manager + bid
        expect(await backupVault.basketUnits(assetManager.address)).to.equal(issueAmount.div(2).add(buyAmtBid))

        // Check RToken supply - Should have burnt the obtained amount from auctions
        // It should at the end be 95% of the original supply (50% already in Token 1 plus 45% coming from auction)
        expect(await rToken.totalSupply()).to.equal(issueAmount.sub(buyAmtBidRSRFinal))
        expect(await rToken.totalSupply()).to.equal(startingTotalSupply.mul(95).div(100))

        // Check Rtoken price is stable
        expect(await rTokenAsset.priceUSD(main.address)).to.equal(fp('1'))
      })
    })
  })
})
