// SPDX-License-Identifier: BlueOak-1.0.0
pragma solidity 0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "contracts/p0/assets/collateral/ATokenCollateralP0.sol";
import "contracts/p0/libraries/Auction.sol";
import "contracts/p0/interfaces/IAsset.sol";
import "contracts/p0/interfaces/IAssetManager.sol";
import "contracts/p0/interfaces/IMain.sol";
import "contracts/p0/interfaces/IRToken.sol";
import "contracts/p0/interfaces/IVault.sol";
import "contracts/p0/FurnaceP0.sol";
import "contracts/p0/RTokenP0.sol";
import "contracts/p0/StRSRP0.sol";
import "contracts/libraries/CommonErrors.sol";
import "contracts/libraries/Fixed.sol";

import "contracts/p0/main/AssetManagerP0.sol";

/**
 * @title RateHandler
 * @notice Tracks the moving economic factors that compose the base rate, the exchange rate between RToken and BUs
 */
contract RateHandlerP0 is AssetManagerP0 {
    using SafeERC20 for IERC20;
    using Auction for Auction.Info;
    using EnumerableSet for EnumerableSet.AddressSet;
    using Oracle for Oracle.Info;
    using FixLib for Fix;

    // ECONOMICS
    //
    // base factor = exchange rate between Vault BUs and RTokens
    // base factor = b = _meltingFactor() / _basketDilutionFactor()
    // <RToken> = b * <Basket Unit Vector>
    // Fully capitalized: #RTokens <= #BUs / b

    Fix private _historicalBasketDilution; // the product of all historical basket dilutions
    Fix private _prevBasketRate; // redemption value of the basket in fiatcoins last update

    constructor() {
        _prevBasketRate = vault.basketRate();
        _historicalBasketDilution = FIX_ONE;
    }


    /// @return Whether the vault is fully capitalized
    function fullyCapitalized() public view override returns (bool) {
        return fromBUs(vault.basketUnits(address(this))) >= main.rToken().totalSupply();
    }

    /// {qRTok} -> {qBU}
    function toBUs(uint256 amount) public view override returns (uint256) {
        if (main.rToken().totalSupply() == 0) {
            return amount;
        }

        // (_meltingFactor() / _basketDilutionFactor()) * amtBUs
        return baseFactor().mulu(amount).toUint();
    }

    /// {qBU} -> {qRTok}
    // solhint-disable-next-line func-param-name-mixedcase
    function fromBUs(uint256 amtBUs) public view override returns (uint256) {
        if (main.rToken().totalSupply() == 0) {
            return amtBUs;
        }

        // (_basketDilutionFactor() / _meltingFactor()) * amount
        return toFix(amtBUs).div(baseFactor()).toUint();
    }

    /// @return {qRTok/qBU} The base factor
    function baseFactor() public view override returns (Fix) {
        return _meltingFactor().div(_basketDilutionFactor());
    }

    // ==== Internal ====

    /// @return {none) Denominator of the base factor
    function _basketDilutionFactor() internal view returns (Fix) {
        Fix currentRate = vault.basketRate();

        // Assumption: Defi redemption rates are monotonically increasing
        Fix delta = currentRate.minus(_prevBasketRate);

        // r = p2 / (p1 + (p2-p1) * (1-f))
        Fix r = currentRate.div(_prevBasketRate.plus(delta.mul(FIX_ONE.minus(main.config().f))));
        Fix dilutionFactor = _historicalBasketDilution.mul(r);
        require(dilutionFactor.gt(FIX_ZERO), "dilutionFactor cannot be zero");
        return dilutionFactor;
    }

    /// @return {none} Numerator of the base factor
    function _meltingFactor() internal view returns (Fix) {
        Fix totalSupply = toFix(main.rToken().totalSupply()); // {RTok}
        Fix totalBurnt = toFix(main.furnace().totalBurnt()); // {RTok}
        if (totalSupply.eq(FIX_ZERO)) {
            return FIX_ONE;
        }

        // (totalSupply + totalBurnt) / totalSupply
        return totalSupply.plus(totalBurnt).div(totalSupply);
    }

    /// Returns the oldest vault that contains nonzero BUs.
    /// Note that this will pass over vaults with uneven holdings, it does not necessarily mean the vault
    /// contains no collateral._oldestVault()
    function _oldestVault() internal view returns (IVault) {
        for (uint256 i = 0; i < pastVaults.length; i++) {
            if (pastVaults[i].basketUnits(address(this)) > 0) {
                return pastVaults[i];[]
            }
        }
        return vault;
    }

    /// @param amount {qBU} Total quantity of BUs across all vaults, not just the current one
    function _allBUs() internal view returns (uint256 amount) {
        amount += vault.basketUnits(address(this));
        for (uint256 i = 0; i < pastVaults.length; i++) {
            amount += pastVaults[i].basketUnits(address(this));
        }
    }

    /// Accumulates current metrics into historical metrics
    function _accumulate() internal {
        _historicalBasketDilution = _basketDilutionFactor();
        _prevBasketRate = vault.basketRate();
    }

    /// Determines what the largest collateral-for-collateral trade is.
    /// Algorithm:
    ///    1. Target a particular number of basket units based on total fiatcoins held across all collateral.
    ///    2. Choose the most in-surplus and most in-deficit collateral assets for trading.
    /// @return Sell collateral
    /// @return Buy collateral
    /// @return {sellTokLot} Sell amount
    /// @return {buyTokLot} Buy amount
    function _largestCollateralForCollateralTrade()
        internal
        returns (
            ICollateral,
            ICollateral,
            uint256,
            uint256
        )
    {
        // Calculate a BU target (if we could trade with 0 slippage)
        Fix totalValue; // {attoUSD}
        for (uint256 i = 0; i < _alltimeCollateral.length(); i++) {
            ICollateral a = ICollateral(_alltimeCollateral.at(i));
            Fix bal = toFix(IERC20(a.erc20()).balanceOf(address(this)));

            // {attoUSD} = {attoUSD} + {attoUSD/qTok} * {qTok}
            totalValue = totalValue.plus(a.priceUSD(main).mul(bal));
        }
        // {BU} = {attoUSD} / {attoUSD/BU}
        Fix targetBUs = totalValue.div(vault.basketRate());

        // Calculate surplus and deficits relative to the BU target.
        Fix[] memory surplus = new Fix[](_alltimeCollateral.length());
        Fix[] memory deficit = new Fix[](_alltimeCollateral.length());
        for (uint256 i = 0; i < _alltimeCollateral.length(); i++) {
            ICollateral a = ICollateral(_alltimeCollateral.at(i));
            Fix bal = toFix(IERC20(a.erc20()).balanceOf(address(this))); // {qTok}

            // {qTok} = {BU} * {qTok/BU}
            Fix target = targetBUs.mulu(vault.quantity(a));
            if (bal.gt(target)) {
                // {attoUSD} = ({qTok} - {qTok}) * {attoUSD/qTok}
                surplus[i] = bal.minus(target).mul(a.priceUSD(main));
            } else if (bal.lt(target)) {
                // {attoUSD} = ({qTok} - {qTok}) * {attoUSD/qTok}
                deficit[i] = target.minus(bal).mul(a.priceUSD(main));
            }
        }

        // Calculate the maximums.
        uint256 sellIndex;
        uint256 buyIndex;
        Fix surplusMax; // {attoUSD}
        Fix deficitMax; // {attoUSD}
        for (uint256 i = 0; i < _alltimeCollateral.length(); i++) {
            if (surplus[i].gt(surplusMax)) {
                surplusMax = surplus[i];
                sellIndex = i;
            }
            if (deficit[i].gt(deficitMax)) {
                deficitMax = deficit[i];
                buyIndex = i;
            }
        }

        ICollateral sell = ICollateral(_alltimeCollateral.at(sellIndex));
        ICollateral buy = ICollateral(_alltimeCollateral.at(buyIndex));

        // {qSellTok} = {attoUSD} / {attoUSD/qSellTok}
        Fix sellAmount = surplusMax.div(sell.priceUSD(main));

        // {qBuyTok} = {attoUSD} / {attoUSD/qBuyTok}
        Fix buyAmount = deficitMax.div(buy.priceUSD(main));
        return (sell, buy, sellAmount.toUint(), buyAmount.toUint());
    }

    /// Prepares an auction pair for revenue RSR + revenue RToken that is sized `f:1-f`
    /// @return launch Should launch auction 1?
    /// @return launch2 Should launch auction 2?
    /// @return auction An auction selling `asset` for RSR, sized `f`
    /// @return auction2 An auction selling `asset` for RToken, sized `1-f`
    function _prepareRevenueAuctionPair(IAsset asset)
        internal
        returns (
            bool launch,
            bool launch2,
            Auction.Info memory auction,
            Auction.Info memory auction2
        )
    {
        // Calculate the two auctions without maintaining `f:1-f`
        Fix bal = toFix(asset.erc20().balanceOf(address(this)));
        Fix amountForRSR = bal.mul(main.config().f);
        Fix amountForRToken = bal.minus(amountForRSR);

        (launch, auction) = _prepareAuctionSell(
            main.config().minRevenueAuctionSize,
            asset,
            main.rsrAsset(),
            amountForRSR.toUint(),
            Fate.Stake
        );
        (launch2, auction2) = _prepareAuctionSell(
            main.config().minRevenueAuctionSize,
            asset,
            main.rTokenAsset(),
            amountForRToken.toUint(),
            Fate.Melt
        );
        if (!launch || !launch2) {
            return (false, false, auction, auction2);
        }

        // Resize the smaller auction to cause the ratio to be `f:1-f`
        Fix expectedRatio = amountForRSR.div(amountForRToken);
        Fix actualRatio = toFix(auction.sellAmount).divu(auction2.sellAmount);
        if (actualRatio.lt(expectedRatio)) {
            Fix smallerAmountForRToken = amountForRSR.mul(FIX_ONE.minus(main.config().f)).div(main.config().f);
            (launch2, auction2) = _prepareAuctionSell(
                main.config().minRevenueAuctionSize,
                asset,
                main.rTokenAsset(),
                smallerAmountForRToken.toUint(),
                Fate.Melt
            );
        } else if (actualRatio.gt(expectedRatio)) {
            Fix smallerAmountForRSR = amountForRToken.mul(main.config().f).div(FIX_ONE.minus(main.config().f));
            (launch, auction) = _prepareAuctionSell(
                main.config().minRevenueAuctionSize,
                asset,
                main.rsrAsset(),
                smallerAmountForRSR.toUint(),
                Fate.Stake
            );
        }
    }

    /// Prepares an auction where *sellAmount* is the independent variable and *minBuyAmount* is dependent.
    /// @param minAuctionSize {none}
    /// @param sellAmount {qSellTok}
    /// @return false if it is a dust trade
    function _prepareAuctionSell(
        Fix minAuctionSize,
        IAsset sell,
        IAsset buy,
        uint256 sellAmount,
        Fate fate
    ) internal returns (bool, Auction.Info memory auction) {
        sellAmount = Math.min(sellAmount, sell.erc20().balanceOf(address(this)));

        // {attoUSD} = {attoUSD/qSellTok} * {qSellTok}
        Fix rTokenMarketCapUSD = main.rTokenAsset().priceUSD(main).mulu(main.rToken().totalSupply());
        Fix maxSellUSD = rTokenMarketCapUSD.mul(main.config().maxAuctionSize); // {attoUSD}
        Fix minSellUSD = rTokenMarketCapUSD.mul(minAuctionSize); // {attoUSD}

        // {qSellTok} < {attoUSD} / {attoUSD/qSellTok}
        if (sellAmount == 0 || sellAmount < minSellUSD.div(sell.priceUSD(main)).toUint()) {
            return (false, auction);
        }

        sellAmount = Math.min(sellAmount, maxSellUSD.div(sell.priceUSD(main)).toUint()); // {qSellTok}
        Fix exactBuyAmount = toFix(sellAmount).mul(sell.priceUSD(main)).div(buy.priceUSD(main)); // {qBuyTok}
        Fix minBuyAmount = exactBuyAmount.minus(exactBuyAmount.mul(main.config().maxTradeSlippage)); // {qBuyTok}

        return (
            true,
            Auction.Info({
                sell: sell,
                buy: buy,
                sellAmount: sellAmount,
                minBuyAmount: minBuyAmount.toUint(),
                clearingSellAmount: 0,
                clearingBuyAmount: 0,
                startTime: block.timestamp,
                endTime: block.timestamp + main.config().auctionPeriod,
                fate: fate,
                isOpen: false
            })
        );
    }

    /// Prepares an auction where *minBuyAmount* is the independent variable and *sellAmount* is dependent.
    /// @param maxSellAmount {qSellTok}
    /// @param targetBuyAmount {qBuyTok}
    /// @return false if it is a dust trade
    function _prepareAuctionBuy(
        Fix minAuctionSize,
        IAsset sell,
        IAsset buy,
        uint256 maxSellAmount,
        uint256 targetBuyAmount,
        Fate fate
    ) internal returns (bool, Auction.Info memory emptyAuction) {
        (bool trade, Auction.Info memory auction) = _prepareAuctionSell(minAuctionSize, sell, buy, maxSellAmount, fate);
        if (!trade) {
            return (false, emptyAuction);
        }

        if (auction.minBuyAmount > targetBuyAmount) {
            auction.minBuyAmount = targetBuyAmount;

            // {qSellTok} = {qBuyTok} * {attoUSD/qBuyTok} / {attoUSD/qSellTok}
            Fix exactSellAmount = toFix(auction.minBuyAmount).mul(buy.priceUSD(main)).div(sell.priceUSD(main));

            // {qSellTok} = {qSellTok} / {none}
            auction.sellAmount = exactSellAmount.div(FIX_ONE.minus(main.config().maxTradeSlippage)).toUint();
            assert(auction.sellAmount < maxSellAmount);

            // {attoUSD} = {attoUSD/qRTok} * {qRTok}
            Fix rTokenMarketCapUSD = main.rTokenAsset().priceUSD(main).mulu(main.rToken().totalSupply());
            Fix minSellUSD = rTokenMarketCapUSD.mul(minAuctionSize);

            // {qSellTok} = {attoUSD} / {attoUSD/qSellTok}
            uint256 minSellAmount = minSellUSD.div(sell.priceUSD(main)).toUint();
            if (auction.sellAmount < minSellAmount) {
                return (false, emptyAuction);
            }
        }

        return (true, auction);
    }
}
